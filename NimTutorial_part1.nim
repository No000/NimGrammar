# Nimのチュートリアルのパート1
# Nim ver 1.0.4
# 基本的な知識が前提なので、未経験者はNimBasicsから
#===================================================================================
# イントロダクション
# 全てのコードはNimstyleguide(https://nim-lang.org/docs/nep1.html)に従い書かれている

#====================================================================================
# 最初のプログラミング
# This is comment
echo "What's your name?"
var name : string = readLine(stdin)

echo "Hi", name, '!'
# readLine関数やecho関数は、暗黙的にインポートされるシステムモジュールに属している
#====================================================================================
# コンパイル方法
# nim compile --run filename.nim
# compileはC言語を経由してクロスコンパイルを行う
# その際のｃコンパイラの指定はfilename.cfg.nimファイルで指定できる
# --runはコンパイルと同時に実行を行うオプション
# -rと省略することができる

# 引数の指定
# nim c -r filename.nim arg1 arg2

# リリースバージョンをコンパイルする方法
# nim c -d:release filename.nim
# このオプションによりランタイムチェックがオフとなり、最適化オプションがONとなる
#====================================================================================
# Nimの字句要素は（文字列）リテラル、識別子、キーワード、コメント、演算子、その他の句読点
# により構成されるいる
# 文字列リテラルは二重引用符("")、文字リテラルは単一引用符('')に囲まれている
# 三個の二重引用符"""..."""で、複数行（エスケープ文字を無視）の記述ができる
echo """
sdc
sdcasdc
"""
# HTML文の埋め込みとかに便利

#====================================================================================
# コメント
# 1行の通常のコメントは#を1文字、行頭に配置する
# ドキュメンテーションコメントは##のように、2文字で表す
# ドキュメンテーションコメントとはjavadocのように、ドキュメントを作成する際に利用されるコメント
#-------------------------------------------------------------------------------------------
# 複数行のコメント
# 複数行にわたるコメントは#[]#の中に記述する.

#[
  Nim
  is
  very
  useful
]#

#[
  csadc
  #[
    ネストすることもできる
  ]#
]#

#=================================================================================================
# 数値
# 読みやすくするために_(アンダーバーを使用することができる)
# 浮動小数点のリテラルとしてeかEを使用できる。.10e9
# 先頭に16進数：0x, 2進数：0b,8進数：0o

#=================================================================================================
# var宣言
# var宣言により、新しいローカル変数またはグローバル変数を宣言することができる
# インデントを利用することにより、まとめることができる

var
  x, y : int
  # 間にコメントを挟むことができる
  a, b, c :string

#=================================================================================================
# 割り当てステートメント
# いまいちピンとこないが、代入演算子の説明になっているのだと思う
# varだといつでも変更が可能な変数なため使い方に注意
var
  a ,b : int = 3
echo a, b
a = 12
echo a, b
#=================================================================================================
# constans
# 定数宣言は、constで宣言を行う
# 定数の値は変更することができず、コンパイル時に評価できる必要がある
# 要は標準入力を入れる器とは使えず、コンパイル時に何らかの数値を入れておく必要がある

const
  x = 1
  # ここにもコメントをかけるよ！
  a = 1
  z = a + 1 # これはコンパイルが通る！

#=================================================================================================
# let宣言
# let宣言は、var宣言のように動くことができるが、一回でも値を入れてしまうと変更ができなくなる

let
  a = 12

# constとの違いを書くなら
const input = readLine(stdin) # これは怒られる
let input = readLine(stdin) # これはOK

#=================================================================================================
# 制御構文
# if文
let name = readLine(stdin)

if name == "" :   # ""は空文字
  echo "名無しなのかい？"
elif name = "名前" :
  echo == "名前が名無しなのは草"
else:
  echo "Hi", name, "!"
#-------------------------------------------------------------------------------------------------
# case文
# コンマ区切りや範囲での条件の設定ができる
# case文は基本何らかの条件を通さないとエラーになるが、
# elseを使うことにより、条件に当てはまらなかった場合の処理をかける
case a
of 1:
  echo "a = 1"
of 1,2,4:
  echo "a = 1,2,4"
of 1..8 :
  echo "a = 1~8"
else: discard
# discardを利用することにより、breakのように何もしない処理をかける
#------------------------------------------------------------------------------------------------
# While文
# 単純なループ文、よく無限ループで聞くやつ
echo "What's your name?"
var name = readLine(stdin)
while name == "":
  echo "Please your name?"
  name = readLine(stdin)
echo name
#-----------------------------------------------------------------------------------------------
# For文
# for文は、組み込み関数以外はPyhtonと特に違いはない
echo "Counting to ten"
for i in countup(1, 11):    # 変数iは暗黙的に宣言されている
  echo i
# countup関数は組み込み関数で、指定の範囲を数え上げて行きます。
# 類似コードとして
echo "Counting to 10 :"
var i = 1
while i <= 10:
  echo i
  inc(i)

# カウントダウンしながらループするには、組み込み関数countdownを利用できる
# あんまつかわない…？
echo "Coundown down from 10 to 1 :"
for i in countdown(10..1):
  echo i

# カウントアップ関数をいつも使うのはだるいので、短く済ませれるイテレータがある
# <数値>..<数値>である
for i in 1..10 :
  echo i

# `<数値> <= x < <数値>`のように数値を含めたくない場合は
# ^または<を使用することで実現することができる
for i in 1..<10:
  echo i

var s = "some string"
for i in 0..^s.len :
  echo i

# 他にイテレータとして便利なコレクション（配列やシーケンスのようなやつ）の関数
# items ：指定された配列の要素を提供する関数（可変）
# mitems：指定された配列の要素を提供する関数（不変）

# pairs  ：配列のインデックスやインデックス番号を提供する関数（可変）
# mpairs ：配列のインデックスやインデックス番号を提供する関数（不変）
for index, items in ["a", "b"].pairs:
  echo items, "at index ", index

#-----------------------------------------------------------------------------------------
# ブロックとスコープ
# スコープ：有効範囲
# ブロック：インデントされているところ
# ローカル変数のような概念のこと

# forやwhileといったループは、自動敵にスコープやブロックが有効となっています
while false:
  var x = "hi"
echo x # error

# block宣言をすることにより明示的にブロックを宣言することができる
block myblock:  # myblockは任意
  var x = "hi"
echo x # error

#-----------------------------------------------------------------------------------------
# break宣言
# whileやforループをする際にblock宣言を応用することで
# goto文のような処理をすることができる（goto文程自由ではないが…）
block myblock:
  echo "entering block"
  while true:
    echo "looping"
    break # block内でのブレイクではない
  echo "still in block"

block myblock2:
  echo "entering block"
  while true:
    echo "looping"
    break myblock2 # これはblock内へとbreakする

#-----------------------------------------------------------------------------------------
# コンテニュー宣言
# 他のプログラミング言語のように、次のループに即座にジャンプする。
while true:
  let x = readLine(stdin)
  if x == "": continue
  echo x

#-----------------------------------------------------------------------------------------
# When定義
# Cのifdefのような存在
# if文に似た存在だが、少し違う点がある。
#[
  ・コンパイラーによって評価されるため、各条件は定数出なければならない
  ・ブランチ内のステートメントは新しいスコープを開くことはない
  ・コンパイラ自身がコンパイルする際にセマンティックをチェックし、
    trueと評価される最初の条件に該当する、コードを生成する
]#

when system.hostOS == "Windows":
  echo "runnning on Windows!"
elif system.hostOS == "linux":
  echo "running on linux"
elif system.hostOS == "macosx"
  echo "running on Mac OS X!"
else:
  echo "unknown operating system"

# 以上のようにプラットホーム固有のコードを作ることができる

#==========================================================================================
# 宣言とインデント
# シンプルステートメント(1行)とコンプレックスステートメント（複数行）は区別される
# 割り当て、プロシージャの宣言やreturnの宣言はシンプルステートメントに該当します。
# 他のステートメントを含めることはできません
# 要はif x: <> if x :みたいなことはかけないよということ

# if,when,for,while等のコンプレックスステートメントには、他のステートメントを含めることができます。
# コンプレックスステートメントは可読性のため、常にインデントをする必要がある

# 単一の割り当てステートメントにインデント葉必要ない
if x : x = false

# ifがネストされているので、インデントが必要
# ネストとは、if文の中に別のif文があるようなこと
if x:
  if y:
    y = false
  else:
    y = true

# 2つの処理が条件に従うため、インデントが必要
if x:
  x = false
  y = false

# 式の任意の場所でインデントを行うことができる
if thisIsaLongCondition() and
    thisIsAnotherLongcondition(1,
      2, 3, 4):
  x = true
# 伝統として、式内のインデントは演算子・開き括弧（1っ個目の括弧）・カンマの後に
# 設けることが望ましい

# 括弧()とセミコロン;を用いることにより、式のみのステートメントを作成することができる
const fac4 = (var x = 1; for i in 1..4: x *= i; x)
# これはコンパイル時に計算が行われます。

#==================================================================================
# プロシージャ
# echo やreadLineといったコマンドを作成するには、定義してあげる必要がある。
# 要は、メソッドや関数の作り方ってこと。
# Nim言語においては、procキーワードを利用して定義する。
proc yes(questions: string): bool =
  echo questions, "(y/n)"
  while true:
    case readLine(stdin)
    of "y", "Y", "yes", "Yes": return true
    of "n", "N", "no", "No": return false
    runnableExamples: echo "Please be clear : yes or no"

# このプロシージャの名前はyesとなる
# 引数の型はString型
# 戻り値の型はbool型
# return文は、プロシージャがただちに抜け出すもの。
# この際組み込んだ、Which文はbool型で返すもので無ければならない
# おそらくC言語から学び始めると、最後にreturnがないのが違和感を沸くかも知れないが
# 次に説明されているresult変数があるので問題はない

#--------------------------------------------------------------------------------------------------
# result変数
# 変数であってステートメントではない、注意
# 値を返すプロシージャでは、暗黙的に宣言がなされている変数になります。

# return文で変数等を指定せず返す場合は、return resultの省略形となります。
# return文等が宣言されなかった場合、result変数がプロシージャの最後に自動的に返されます。

# result変数はプロシージャの初めで暗黙的に宣言されているので、もしvar resultのように宣言すると
#reult変数はシャドーイングされます。
#（既存の変数へそのスコープ内でアクセスできなくすること、イミュータブルプログラミング等で使用される）

# 参照データ型の際はプロシージャ開始時の初期値がnilになっているので手動で初期化する必要がある。

#---------------------------------------------------------------------------------------------------
# パラメータ

#[ パラメータはproc test(arg1: int) =
                          ↑これがパラメータ
    引数はtest(1)
               ↑これが引数
  パラメータは駐車場で、引数が車のイメージ
  参考
  https://docs.microsoft.com/ja-jp/previous-versions/visualstudio/visual-studio-2008/9kewt1b3(v=vs.90)?redirectedfrom=MSDN
]#

# 通常、プロシージャでのパラメータは不変です。
# だが、プロシージャ内部で変数にする必要がある場合、する方法がある
# プロシージャ内部でvarをもちいて引数のシャドウイングをする方法である

proc printSeq(s: seq, nprinted: int = -1) =   # 引数のnprinted
  # 変数キーワードを使用しシャドウイング
  var nprinted = if nprinted == -1 : s.len else: min(nprinted, s.len)
  for i in 0 .. <nprinted:
    echo s[i] 

# どういう場面でこの機能を使うかというと
# プロシージャで、引数を修正したい場合に使用する

# ;でvarで宣言している部分とa,b(おそらくlet?で暗黙定義)と分けている
proc divmod(a, b : int ; res, rmainder: var int) =
  res = a div b
  remainder = a mod b

var
  x, y : int

# 推奨はされないが、divmod 8, 5, x, yでも動く
divmod(8, 5, x, y)
echo x
echo y

# var引数は、プロシージャによって変更でき呼び出し元（引数）に反映される
# 上の例では、varパラメータの変わりにタプルを使うのが適切

#---------------------------------------------------------------------------------
# Discard文
# プロシージャからの戻り値を無視する方法としてdiscord文を使用する方法がある

discard yes("May I ask a pointless question?")

# プロシージャ自体にdiscardaleプラグマで宣言している場合
# 暗黙的に戻り値を無視させることができる

proc p(x, y: int) {.discardable} =
  return x + y

p(3, 4)

# またdiscard文を使用してコメント文を書くことはできるが
# コメントの紹介から除外されているので、非推奨なのかも

#---------------------------------------------------------------------------------
# 名前付き引数
# プロシージャの引数は複数あり複雑なのが一般的である
# また、パラメータの順序も明確でない場合がある
# （要はパラメータの一つが何番目に何があるかわからなくね？ってこと）
# その解決法として、名前付き引数がある

# 機能としては、引数を名前付きで渡すことで
# パラメータの宣言された順番を気にしなくて良くなる

# また、複雑なデータ型のプロシージャに使われるが
# どの引数がどのパラメータに属するかが明確となる
proc createWindow(x, y, width, height: int; title: string; show: bool) =
  ...

var w = createWindow(show = true, title = "My Application", x = 0, y = 0, height = 600, width = 800)

# 名前付き順序を利用しているため、引数の順序は特に重要ではなくなっているが
# 可読性が失われる

var w = createWindow(0, 0, title = "My Application", height = 600, width = 800, true)

# この際にコンパイラがチェックすることは、パラーメータ1つにつき
# 値が一つ渡されているかである

#-----------------------------------------------------------------------------------------
# デフォルト値
# プロシージャが呼ばれた際に、パラメータが無かった際に使用される値のこと
proc createWindow(x = 0, y = 0, width = 500, height = 700, title = "unknown", show = true): window = 

var w  createWindow(title = "My Application", height = 600, width = 800)

# この際は、showがデフォルト値として使用される
# また、デフォルト値を含めたパラメータに対しても型推論は適用されるので
# title string = "unknown"と記載する必要はない

#------------------------------------------------------------------------------------
# プロシージャのオーバーロード
# Nim言語は、C++と同様のプロシージャのオーバーロードを行うことができる

proc toString(x: int): string =
  if x == 13: result = "true"
  else: result = "false"

proc toString(x: bool): string =
  if x: result = "true"
  else: result = "false"

echo toString(13)   # toString(x: int)プロシージャを呼んでいる
echo toString(true) # toString(x: bool)プロシージャを呼んでいる

# 上の例では、toStringのプロシージャでintとboolの型の違いで
# 違う関数としてみなされていることがわかる、これがオーバーロードである
# toStringはNimでは$演算子のことのようである
# これらは、コンパイラにより最適な関数が選択される
# オーバーロードに関しての詳しい説明はマニュアルに記載されている

#----------------------------------------------------------------------------------
# 演算子
# Nimのライブラリーでは、オーバーロードが多用されています。
# 理由の一つとして、（a + b）と(+ a)という使われ方をしたとした場合
# 引数が前者の場合2つであるが、後者の場合一つとなる
# Nim言語は後置演算子をサポートしていない。

# and,or,not等のキーワードを除いて演算子は以下の記号として以下を使用することができる
# +,-,*,/,\,<,>,=,@,$,~,&,%,!,?,^,.,|
# しかし、@,!,?,+,~を使用をオーバーロードし、使用すると可読性が失われる可能性が高い
# 演算子の優先順位は最初から順である
# 新しい演算子を定義する際には、記号を`(バッククォート)で定義する
# またこれはオーバーロードなので以前の機能もちゃんと維持している
proc `$` (x: myDataType): string = ...

# `(バッククォート)で囲っている場合、関数と同じ感覚で呼び出すことが可能である
if `==`( `+`(3,4), 7): echo "True"
`+`(2,4).echo # これもいける

#-----------------------------------------------------------------------------------------
# 前方宣言
# C言語のプロトタイプ宣言

# すべての変数とプロシージャ等は、はじめに宣言する必要がある
# なぜ必要かというとNimはメタプログラミングをサポートしている言語
# だからである、


# 相互再帰の場合では使用することができない

# やり方は簡単で=プロシージャの本体を省略するだけでよい

proc even(n: int): bool   # 前方宣言

proc odd(n: int):bool =
  assert(n > 0)
  if n == 0: false
  else:
    n == 1 or even(n - 1)

proc even(n: int):bool =
  assert(n >= 0)
  if n == 0: false
  else:
    n == 0 or odd(n - 1)

# 以上のようにプロシージャoddの中では、evenが必要なため前方宣言をする必要がある
# この言語の新しいバージョンでは前方宣言の要件がすくなくなるらしい（どう減らすんだろ…？）

#==========================================================================================
# イテレーター
# 次のプログラムはシンプルなカウントプログラムである
echo "Counting to ten : "
for i in countup(1,10):
  echo i

# このcountup()を作って見よう
proc countup(a, b: int): int =
  var res = a
  while res <= b:
    return res
    inc(reset)

# しかし、これは動かない
# なぜならこのように繰り返しつつ戻り値を出す場合、プロシージャの処理を終わらせねばならないからである。
# このように継続しつつ出力を繰り返す場合に使うのがイテレータである。

iterator countup(a, b: int): int =
  var res = a
  while res <= b:
    yield res
    inc(res)

# これならば動く

# プロシージャとの違いは
# for文以外からは呼び出すことができない
# イテレータはreturn変数で返すことはできない（逆に、プロシージャではyieldで返すこと葉できない）
# イテレーターには、暗黙的なresult変数が存在しない
# イテレーターは再帰をサポートしていない
# イテレータを前方宣言することはできない、なぜならコンパリラはイテレータをインラインにしなければならないから
# （一番最後のインラインに限定されるに関しては将来的に撤廃される予定）

# 制限を持ったイテレータとしてclosureイテレータが存在するが、詳しくはfirst iteratorを参照のこと

# イテレーターはプロシージャと同じ名前を付けることが可能である
# なぜなら、名前空間を独自に持っているからである。

# strutilsモジュールのようにイテレーターの返す値を、同じ名前のプロシージャでラップしてまとめて返すことが一般らしい

#=======================================================================================================================
# 基本的なデータ型
# 組み込みデータ型や、そこで使う演算子を紹介するらしい
# ---------------------------------------------------------------------------------------------------------------------
# Boolean（Nimではboolと呼ぶ）
# いわゆるtrueとfalseの定義された値を出す型のこと
# while,if,elif,whenの条件に使用される

# 演算子のnot,and,or,xor,<,<=,>=, !=, ==がbool型として定義されている
# andとorは以下の例では、短絡評価の動きをしています。
while p != nil and p.name != "xyz":
  # p.name is not evaluated if p == NilAccessError
  p = p.next
# 短絡評価：左辺を評価した段階で評価が決定するもの

#----------------------------------------------------------------------------------------------------------------------
# Characters
# CharactersはChar型と呼ばれ、常に1バイトの大きさである。
# そのためほとんどのUTF-8文字を表すことができないが、マルチバイトのUTF-8 文字を構成する文字であれば表すことができる
# 表す際は'（単一引用符）で表す
# Char型は演算子の==,<,<=,>,>=で比較をすることが可能
# 演算子$を使用することにより、Char型をString型に変換することができる
# Char型では整数を混ぜることはできない
# Char型の序数値を求めたい場合はordプロシージャを使用する
# 整数から文字への変換は、chrプロシージャを使用する

#----------------------------------------------------------------------------------------------------------------------------
# String型
#[
  Nim言語においての文字列は可変です
]#